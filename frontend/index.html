<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RSTS</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; background: #222; color: #eee; }
    #container { max-width: 1000px; margin: 0 auto; }
    .row { margin-bottom: 12px; display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    button { padding: 8px 14px; border: none; border-radius: 6px; background: #444; color: #fff; cursor: pointer; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    select, input { padding: 6px; border-radius: 4px; border: 1px solid #555; background: #333; color: #fff; }
    .pane { flex:1; min-width:320px; }
    .box  { white-space: pre-wrap; background:#111; color:#eee; padding:12px; border-radius:8px; height:38vh; overflow-y:auto; font-size:15px; }
    label.switch { display:flex; align-items:center; gap:6px; }
  </style>
</head>
<body>
<div id="container">
  <h2>Real Time Translation System</h2>

  <div class="row">
    <label>Source Language:</label>
    <select id="lang">
      <!-- 和后端协议保持一致：auto / zh / en / ja / es / fr -->
      <option value="auto">AUTO</option>
      <option value="zh">Chinese</option>
      <option value="en">English</option>
      <option value="ja">Japanese</option>
      <option value="es">Spanish</option>
      <option value="fr">French</option>
    </select>

    <label>Target:</label>
    <select id="tgt">
      <!-- 目标语言直接用同一套代码 -->
      <option value="en">English</option>
      <option value="zh">Chinese</option>
      <option value="fr">French</option>
      <option value="ja">Japanese</option>
      <option value="es">Spanish</option>
    </select>

    <label class="switch"><input type="checkbox" id="autoscroll" checked /> AUTO SCROLL</label>
    <label class="switch"><input type="checkbox" id="doTrans" checked /> TRANSLATE</label>
    <label class="switch"><input type="checkbox" id="doTTS" /> TTS</label>
  </div>

  <div class="row">
    <button id="start">START</button>
    <button id="stop" disabled>STOP</button>
    <button id="clear">CLEAR</button>
  </div>

  <div class="row" style="align-items:flex-start;">
    <div class="pane">
      <div style="margin-bottom:6px;">Source (ASR)</div>
      <div id="logSrc" class="box"></div>
    </div>
    <div class="pane">
      <div style="margin-bottom:6px;">Translation</div>
      <div id="logTgt" class="box"></div>
    </div>
  </div>

  <audio id="ttsPlayer" style="display:none;"></audio>
</div>

<script>
  const BACKEND_BASE = 'http://127.0.0.1:8001';

  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');
  const clearBtn = document.getElementById('clear');
  const langEl   = document.getElementById('lang');
  const tgtEl    = document.getElementById('tgt');
  const autoScrollEl = document.getElementById('autoscroll');
  const doTransEl= document.getElementById('doTrans');
  const doTTSEl  = document.getElementById('doTTS');
  const ttsPlayer= document.getElementById('ttsPlayer');
  const logSrc = document.getElementById('logSrc');
  const logTgt = document.getElementById('logTgt');

  let ws, mediaStream, processor, audioCtx, source;
  const SAMPLE_RATE = 16000;

  class TTSQueue {
    constructor(player, langGetter) {
      this.player = player;
      this.queue = [];
      this.playing = false;
      this.langGetter = langGetter;
      this._onended = this._onended.bind(this);
      this.player.addEventListener('ended', this._onended);
      this.player.addEventListener('pause', this._onended);
    }
    clear() {
      this.queue = [];
      this.stop();
    }
    stop() {
      try { this.player.pause(); } catch {}
      this.playing = false;
    }
    async enqueueText(text) {
      if (!doTTSEl.checked) return;
      if (!text || !text.trim()) return;
      this.queue.push({ text, lang: this.langGetter() });
      if (!this.playing) this._dequeueAndPlay();
    }
    async _dequeueAndPlay() {
      if (this.playing) return;
      const item = this.queue.shift();
      if (!item) return;
      this.playing = true;

      try {
        const resp = await fetch(`${BACKEND_BASE}/api/tts`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: item.text,
            lang: item.lang.startsWith('zh') ? 'zh' : item.lang
          })
        });
        if (!resp.ok) throw new Error(`TTS http ${resp.status}`);
        const blob = await resp.blob();
        const url = URL.createObjectURL(blob);
        this.player.src = url;
        await this.player.play().catch(()=>{});
      } catch (e) {
        console.log('[TTS] error:', e);
        this.playing = false;
        this._dequeueAndPlay();
      }
    }
    _onended() {
      if (!this.playing) return;
      this.playing = false;
      try { URL.revokeObjectURL(this.player.src); } catch {}
      this._dequeueAndPlay();
    }
  }

  let isTTSPlaying = false;
  ttsPlayer.addEventListener('play',  () => { isTTSPlaying = true; });
  ttsPlayer.addEventListener('ended', () => { isTTSPlaying = false; });
  ttsPlayer.addEventListener('pause', () => { isTTSPlaying = false; });

  const ttsQueue = new TTSQueue(ttsPlayer, () => tgtEl.value);

  doTTSEl.addEventListener('change', () => {
    if (!doTTSEl.checked) ttsQueue.clear();
  });

  function appendLineTo(el, text) {
    const div = document.createElement('div');
    div.textContent = text;
    el.appendChild(div);
    if (autoScrollEl.checked) el.scrollTop = el.scrollHeight;
  }
  function clearLogs() { logSrc.innerHTML = ''; logTgt.innerHTML = ''; }

  function floatTo16BitPCM(float32Array) {
    const len = float32Array.length;
    const buffer = new ArrayBuffer(len * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i = 0; i < len; i++, offset += 2) {
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
    return buffer;
  }

  async function start() {
    ws = new WebSocket(`${BACKEND_BASE.replace('http', 'ws')}/ws`);
    ws.onopen = () => {
      const cfg = {
        language: langEl.value,
        target:   tgtEl.value,
        translate: doTransEl.checked
      };
      ws.send(JSON.stringify(cfg));
      appendLineTo(logSrc, '[ws] connected');
    };
    ws.onmessage = (ev) => {
      try {
        const obj = JSON.parse(ev.data);
        if (obj.type === 'final') {
          if (obj.src && obj.src.trim()) appendLineTo(logSrc, obj.src);
          if (obj.tgt && obj.tgt.trim()) {
            appendLineTo(logTgt, obj.tgt);
            ttsQueue.enqueueText(obj.tgt);
          }
        } else if (obj.type === 'error') {
          appendLineTo(logSrc, '[error] ' + obj.message);
        } else {
          appendLineTo(logSrc, '[msg] ' + ev.data);
        }
      } catch {
        appendLineTo(logSrc, ev.data);
      }
    };
    ws.onclose = () => appendLineTo(logSrc, '[ws] closed');

    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: SAMPLE_RATE,
        channelCount: 1,
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      }
    });
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });
    source = audioCtx.createMediaStreamSource(mediaStream);

    const bufferSize = 4096;
    processor = audioCtx.createScriptProcessor(bufferSize, 1, 1);
    processor.onaudioprocess = (e) => {
      if (isTTSPlaying) return; 
      const input = e.inputBuffer.getChannelData(0);
      const pcm = floatTo16BitPCM(input);
      if (ws && ws.readyState === WebSocket.OPEN) ws.send(pcm);
    };
    source.connect(processor);
    processor.connect(audioCtx.destination);

    startBtn.disabled = true;
    stopBtn.disabled = false;
  }

  function stop() {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send('flush');
      setTimeout(() => { try { ws.send('close'); ws.close(); } catch {} }, 200);
    }
    ttsQueue.clear();
    if (processor) { processor.disconnect(); processor = null; }
    if (source) { source.disconnect(); source = null; }
    if (audioCtx) { audioCtx.close(); audioCtx = null; }
    if (mediaStream) { mediaStream.getTracks().forEach(t => t.stop()); mediaStream = null; }

    startBtn.disabled = false;
    stopBtn.disabled = true;
  }

  startBtn.onclick = start;
  stopBtn.onclick = stop;
  clearBtn.onclick = clearLogs;
</script>
</body>
</html>
